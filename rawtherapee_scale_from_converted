#! /usr/bin/env bash

set -eu

declare -r INSTALL_DIR="$(dirname "$(readlink -e "$0")")"
export PATH="$INSTALL_DIR:$INSTALL_DIR/lib:$PATH"

declare -r SCALING_PROFILE_FILE=$(mktemp)

function delete_tmpfiles() {
	test -e "$SCALING_PROFILE_FILE" && rm -f "$SCALING_PROFILE_FILE"
}
trap delete_tmpfiles EXIT

# TODO remove from exif.sh in photo-scripts once we're using this script
function lookup_image_width_from_exif() {
	local -r photofile=$1
	# yes, there should be a way to get the correct dimension from exif tags (instead of brute forcing
	# exiv2 default output). but I don't know how to do it. some cameras give strange numbers...
	exiv2 -q "$photofile" | grep "Image size" | sed -r 's/Image size\s+:\s+([0-9]+)\sx\s([0-9]+)/\1/'
}

# TODO remove from exif.sh in photo-scripts once we're using this script
function lookup_image_height_from_exif() {
	local -r photofile=$1
	exiv2 -q "$photofile" | grep "Image size" | sed -r 's/Image size\s+:\s+([0-9]+)\sx\s([0-9]+)/\2/' 
}

function compute_scale() {
    local -r photofile=$1
    local -r target_value=$2

    if [[ -v SCALE_BY_HEIGHT ]]; then
        local -r original_value=$(lookup_image_height_from_exif "$photofile")
    else
        local -r original_value=$(lookup_image_width_from_exif "$photofile")
    fi

    bc <<<"scale=4; $target_value/$original_value"
}

function prepare_scaling_profile() {
    local -r scale=$1
    echo "[Resize]
        Enabled=true
        Method=Lanczos
        DataSpecified=0
        Scale=$scale

        [PostResizeSharpening]
        Enabled=true
        Contrast=15
        Method=rld
        Radius=0.5
        Amount=200
        Threshold=20;80;2000;1200;
        OnlyEdges=false
        EdgedetectionRadius=1.9
        EdgeTolerance=1800
        HalocontrolEnabled=false
        HalocontrolAmount=85
        DeconvRadius=0.45
        DeconvAmount=100
        DeconvDamping=0
        DeconvIterations=100"
}

while getopts "nc:q:hp:o" opt; do
    case $opt in
        # in NATIVE_MODE, we assume that the given jpeg file was created by Rawtherapee and
        # that we can find both the original photo file (maybe in raw format) and the sidecar
        # file. The scaling is then done from the original photo file and the sidecar (pp3).
        n )
            declare -r NATIVE_MODE=;;
        c )
            # 1-100
            declare -r JPEG_COMPRESSION=$OPTARG;;
        q )
            # 1-3 (Best compression/Balanced/Best quality)
            declare -r JPEG_QUALITY=$OPTARG;;
        h ) 
            declare -r SCALE_BY_HEIGHT=;;
        o ) 
            declare -r OVERWRITE=;;
	esac
done
shift $(expr $OPTIND - 1 )

test -v NATIVE_MODE || declare -r NATIVE_MODE=

if (( $# < 3 )); then
    echo "[ERROR] Missing parameter, given parameters are: $@" >&2
    exit 1
fi

# the width (default) or height (if passing "-h") to
# FIXME check if valid number   
scale_to=$1

jpeg_file=$2
if ! [[ -e $jpeg_file ]]; then
    echo "[ERROR] converted file ${2+$2 } does not exist" >&2
    exit 1
fi

# can be a directory or a file
target=$3

scale=$(compute_scale "$jpeg_file" "$scale_to")
prepare_scaling_profile "$scale" > "$SCALING_PROFILE_FILE"

# TODO check if target width or height are larger than actual height or width of the source. don't
# apply any scaling in that case, only copy the image file unchanged

# TODO if we're not in NATIVE_MODE, check if jpeg_file is already compressed
#   -> use  identify -format '%Q\n' $jpeg_file 
# if quality is less than N (95?), do not recompress


if [[ -v NATIVE_MODE ]]; then
    source=$(find_original_of_converted "$jpeg_file")
    if [[ -z $source ]]; then
        echo "[ERROR] Could not find original file matching $jpeg_file" >&2
        exit 1
    fi
    conversion_profile=$(find_sidecar_of_converted "$jpeg_file")
    if [[ -z $conversion_profile ]]; then
        echo "[ERROR] No conversion profile matching $jpeg_file" >&2
        exit 1
    fi    
else 
    source=$jpeg_file
fi

rt_process ${OVERWRITE+-o} ${NATIVE_MODE+-p "$conversion_profile"} -p "$SCALING_PROFILE_FILE" \
    ${JPEG_COMPRESSION+-c $JPEG_COMPRESSION} ${JPEG_QUALITY+-q $JPEG_QUALITY} \
    "$source" "$target"